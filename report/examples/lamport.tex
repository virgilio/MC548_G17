\subsection{Ordenação total}

Apresentamos aqui uma versão resumida do algoritmo descrito
em~\cite{lamport78} que garante a ordenação total de eventos em um
sistema distribuído. A ordenação total segue quase diretamente da
definição de relógios lógicos, também introduzidos no artigo.

Relógios lógicos são definidos pela condição a seguir:
\begin{quote}
  Para quaisquer eventos $a$ e $b$, se $a$ ocorre causalmente antes de
  $b$, então o $a$ deve ter ocorrido em um tempo lógico anterior ao de
  $b$\footnote{Usando a notação do Lamport: para quaisquer eventos $a$
    e $b$, se $a \rightarrow b$, então $C(a) < C(b)$}.
\end{quote}
\noindent Qualquer implementação que garanta essa condição é um
relógio lógico. Apesar dessa liberdade dada pela definição,
apresentaremos uma versão específica -- a mesma utilizada na prática
em~\cite{lamport78}. Cada processo $P_i$ possui um relógio $C_i$ que
segue as seguintes regras de implementação:
\begin{itemize}
\item Cada processo $P_i$ incrementa $C_i$ entre quaisquer dois eventos
      consecutivos.
\item Se o evento $a$ em $P_i$ é o envio de uma mensagem $m$, essa
      mensagem contém um \emph{timestamp} $T_m$ que é o valor de $C_i$
      durante o evento $a$.
\item Quando um processo $P_j$ recebe uma mensagem $m$, ele atualiza
      $C_j$ para um valor maior ou igual ao valor atual e a $T_m$.
\end{itemize}

Essas regras de implementação garantem que o relógio atende a condição
que define relógios lógicos definida anteriormente.

Para obter a ordenação total, basta ordenar os eventos pelo valor do
relógio lógico local no momento em que ele ocorreu. Para desempatar,
pode-se usar uma ordenação total arbitrária dos processos, por
exemplo, ordená-los por \emph{pid}. Essa ordenação total é obtida pelo
pseudo-código a seguir:

\begin{lstlisting}[caption={Ordenação total no processo $P_i$}, emph={[2]i,j}, emphstyle={[2]\emph}, mathescape=true, label=totalorder]
type
  clock   : non-negative integer;
  pid     : 0..N-1;

  message = <timestamp, process id, [payload]> // timestamp é o relógio local de quem enviou a mensagem

on process $P_i$

var
  llc : clock; // relógio lógico local

function sendmsg(dest : pid, msg : payload)
  begin
    sent (llc, i, msg) to dest;
    llc := llc + 1;
  end

procedure run_event(event : function)
  begin
    call event
    llc := llc + 1;
  end

on receipt // ativado pelo recebimento de mensagem
  of (ts, j, msg) do
    begin
      // atualiza relógio local
      if (llc < ts)
        llc : = ts;
      llc : = llc + 1;

      // processa mensagem
      process_received_msg(ts, j, msg);
    end

// ordenação total em si: compara dois pares de pid/clock
function compare( (id1, ts1) : pid*clock, (id2, ts2) : pid*clock )
  begin
    if (ts1 != ts2)
      return compare(ts1, ts2); // usa a comparação entre os timestamps
    else
      return compare(id1, id2); // desempata com os pids
  end
\end{lstlisting}

\subsection{Exclusão Mútua}

A partir da ordenação total, é possível implementar um algoritmo de
exclusão mútua em sistemas distribuídos, como o próprio Lamport sugere
na mesma publicação.

O algoritmo, da forma como será descrito, assume que as mensagens entre
quaisquer dois processos são recebidas na mesma ordem em que foram
enviadas e que toda mensagem enviada é recebida em algum momento. Essas
suposições são apenas para evitar outros detalhes de implementação. A
simples utilização de um protocolo TCP garante essas condições.

O algoritmo também assume que a região crítica é concedida inicialmente
a exatamente um processo. Cada processo processo mantém, além do relógio
lógico, uma fila de requisições local. Assumimos que as filas são iniciadas
com a mensagem ``$T_0:P_0$ requests'', onde $T_0$ é o valor inicial de
todos os relógios.
% Copiei a condição inicial da fila direto do Lamport...
% Dúvida: Se todos os clocks começarem em 0, isso não é desnecessário?

O algoritmo é definido da seguinte forma:
\begin{itemize}
\item Para requisitar um recurso, o processo $P_i$ envia uma mensagem
  ``$T_m:P_i$ requests'' para todos os outros processos
  (\emph{broadcast}), e coloca essa mensagem na sua própria fila.
\item Quando um processo $P_j$ recebe a mensagem ``$T_m:P_i$ requests'',
  ele coloca essa mensagem na sua própria fila e envia um
  \emph{ack}\footnote{Sendo este evento o envio de uma mensagem, o
  \emph{ack} também leva consigo um \emph{timestamp}} de volta para
  $P_i$.
\item Para liberar o recurso (sair da região crítica), o processo $P_i$
  remove qualquer ocorrência de ``$T_m:P_i$ requests'' de sua fila e
  envia uma mensagem ``$P_i$ releases'' para todos os outros processos
  (\emph{broadcast}).
\item Quando um processo $P_j$ recebe uma mensagem ``$P_i$ releases'',
  ele remove qualquer ocorrência de ``$T_m:P_i$ requests'' de sua fila.
\item O recurso é concedido ao processo $P_i$ quando
\begin{itemize}
 % melhorar esse texto do item a seguir... ficou tosco usar uma footnote
 \item Existe uma mensagem ``$T_m:P_i$ requests'' na sua fila que é
   ordenada antes de qualquer outra mensagem na sua fila\footnote{Para
   essa ordenação, usamos o \emph{timestamp}, e, como critério de
   desempate, o número do processo}.
\item $P_i$ recebeu de cada um dos outros processos alguma mensagem
  posterior\footnote{Posterior no sentido da ordenação
    total que definimos --- $P_i$ deve ter recebido de cada um dos
    processos $P_j$ com $j < i$ alguma mensagem com \emph{timestamp}
    maior que $T_m$, e de cada dos $P_j$ com $i < j$ alguma mensagem
    com \emph{timestamp} maior ou igual que $T_m$} a $(T_m,P_i)$.
\end{itemize}
\end{itemize}

Para obter uma especificação do algoritmo mais próxima de uma
implementação real, seguimos o mesmo estilo do
pseudo-código~\ref{totalorder}, utilizando inclusive a função
\texttt{on receipt}. A fila é implementada de uma forma um pouco
diferente da especificação anterior. A variável \texttt{q} mantém a
última mensagem recebida de cada processo, servindo como fila (se
olharmos apenas as posições com \texttt{\textbf{req}}) e facilitando a
verificação do \emph{timestamp} para a entrada na região crítica.

\begin{lstlisting}[caption={Exclusão mútua no processo $P_i$}, emph={req,rel,ack}, emph={[2]i,j}, emphstyle={[2]\emph}, mathescape=true]
type
  clock   : non-negative integer;
  pid     : 0..N-1;
  msgtype : (req, rel, ack);

  message = <timestamp, process id, msgtype> // timestamp é o relógio local de quem enviou a mensagem

on process $P_i$

var
  llc : clock; // relógio lógico local
  q : array [0..N-1] of message; // fila

procedure broadcast(msg : msgtype, dest : pid)
  begin
    for all j != i
      sent (llc, i, msg) to dest;
    llc := llc + 1;
  end

main_routine: // Rotina principal em $P_i$: requisição, aquisição e liberação da região crítica
  begin
    // requisição
    q[i] :=  (llc, i, req);
    broadcast(llc, i, req);

    // espera
    while (exists j != i with (timestamp(q[j]), j) < (timestamp(q[i]), i))
      wait;

    // Região Crítica aqui
    critical_region_code();

    // liberação
    q[i] :=  (llc, i, rel);
    broadcast(llc, i, rel);
  end

// chamado pelo \textnormal{\texttt{on receipt}} definido no código anterior
procedure process_received_msg(ts, j, msg)
  begin
    case (msg) of
      req:
        q[j] := (ts, j, req);
        sendmsg(j, ack);
      rel:
        q[j] := (ts, j, rel);
      ack:
        if (type(q[j]) != req)
          q[j] := (ts, j, ack);
    end
  end
\end{lstlisting}
