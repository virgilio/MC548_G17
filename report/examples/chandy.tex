Um grande problema em Sistemas Distribuídos é a dificuldade de
enxergar o estado do sistema como um todo a partir de um processo,
advinda em parte da ausência de uma noção global de tempo. Tal
conhecimento seria muito útil, por exemplo, na determinação de
propriedades estáveis do sistema, isto é, propriedades que uma vez
satisfeitas permanecem verdadeiras, como a terminação de uma
computação distribuída.

Em uma primeira tentativa, um processo que deseja determinar o estado
global poderia simplesmente mandar um pedido a ser propagado a todos
os nós da rede, pedindo que estes lhe mandassem um retrato de seu
estado. Infelizmente, ao combinar todos os estados individuais
amostrados, o estado global obtido pode ser inconsistente, devido à
propagação das mensagens contidas nos canais enquanto a requisição era
feita. Por exemplo, em um banco distribuído, suponha que haja uma
transferência de cem reais da conta de um cliente $A$ para um cliente
$B$. Se o saldo da conta de $A$ é transmitido por um nó e o da de $B$
por outro, seria possível que o saldo de $A$ fosse transmitido
anteriormente à transferência e o de $B$ após, fazendo com que a
quantidade total de dinheiro nas contas fosse maior que a verdadeira.

Chandy e Lamport~\cite{chandyl85} observam que determinar a união
exata dos estados de todos os processos do sistema em um dado instante
não é essencial, bastando muitas vezes que a coleção de estados quando
composta seja coerente. Informalmente, a noção de coerência definida é
quando o estado total amostrado poderia ocorrer em uma sequência de
eventos equivalente à verdadeira.

O modelo computacional adotado pelos autores é o de uma rede formada
por nós e canais de comunicação unidirencionais entre eles. Os podem
acessar seu estado local, alterá-lo, enviar mensagens através de
canais saindo dele e receber mensagens previamente enviadas por outros
nós de canais incidentes. Assume-se que os canais preservam a ordem
das mensagens, não falham e entregam todas as mensagens enviadas
eventualmente. Além dos estados dos nós no sistema, gravaremos também
os estados de cada canal do sistema, isto é, as mensagens ainda não
recebidas enviadas através de cada canal.

O algoritmo em si é simples:

\begin{lstlisting}[caption={Algoritmo de Chandy e Lamport para amostra
  de estado global consistente.}]

var recorded;

function propagate()
  record state;
  recorded := true;
  for each chan in outgoing
    send_marker(chan);
  for each chan in incoming
    start_record(chan);

function receive_marker(chan : channel) 
// marker recebido através de chan
  if (!recorded)
    propagate();
  stop_record(chan);
\end{lstlisting}

Assume-se que algum evento faz com que um ou mais nós iniciem o
algoritmo chamando a função \texttt{propagate}. O algoritmo termina
quando todos os nós tiverem recebido um marcador de todos seus canais
incidentes, e ocorre à parte da computação distribuída principal. É
simples de ver que isso sempre ocorre se o grafo da rede for
fortemente conexo. Os autores afirmam que após o algoritmo ter
terminado pode-se empregar um dos vários mecanismos existentes para
coletar a informação gravada, como fazer com que cada nó propague o
seu estado e os estados novos que receber para seus vizinhos.

Finalmente, os autores definem seu critério de consistência e provam
que o algoritmo dado o satisfaz: se a amostragem começa em um estado
$E_i$ e termina em um estado $E_f$ resultando em um estado $E_a$,
então existem duas sequências de eventos que levam respectivamente
$E_i$ até $E_a$ e $E_a$ até $E_f$. É essa propriedade que é usada para
definir um meio de detecção de propriedades estáveis: basta gravar um
estado global e verificar se a propriedade é válida nesse estado. Como
o estado final é alcançável do estado amostrado através de alguma
sequência de eventos e a propriedade é invariante sob os eventos
ocorridos, a propriedade será válida para o estado global verdadeiro.
