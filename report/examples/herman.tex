
O algoritmo de Herman e Verjus~\cite{hermanv79} usa o esquema de
ordenação com relógios lógicos exposto por Lamport~\cite{lamport78}
para poder replicar uma base de dados através de múltiplas máquinas de
forma consistente. A ideia básica é muito simples e consiste em fazer
com que todas as máquinas enxerguem a mesma sequência de operações na
base de dados. Como as operações são deterministas, isso implica que
todas as bases terão o mesmo estado, ou então, mais precisamente, como
dito pelos autores, ``se toda atividade de usuário parar, as cópias
devem convergir, após um período de tempo finito, para o mesmo
estado''. Segundo os autores, ao contrário de outros algoritmos
semelhantes, este busca ``maximizar o paralelismo minimizando o
travamento global''. Vale notar, porém, que o algoritmo não é
tolerante a falhas.

São definidas quatro operações abstratas que podem ser feitas sobre a
base de dados. Numa \emph{estimação} (\emph{estimate}), a máquina
devolve o valor contido na cópia local do item de dados pedidos
imediatamente. Uma \emph{leitura} (\emph{read}) também devolve esse
valor, mas o faz após garantir que todas as requisições feitas até
então sejam processadas. Uma \emph{escrita} (\emph{write}) altera um
valor de um item de dados, propagando essa mudança para todas as
outras cópias. Enfim, uma \emph{atualização} (\emph{update}) executa
uma sequência de operações de escrita e leitura que são vistas como
atômicas pelos outros processos.

O modelo de comunicação entre os processos é o mesmo daquele da seção
anterior, ou seja, temos canais de comunicação ponto-a-ponto sem
falhas e que preservam a ordem de envio das mensagens. Cada processo
mantém uma fila para cada outro, incluindo ele mesmo, onde ele
registra as requisições pendentes advindas de cada processo. Apenas
quando ele percebe que uma requisição não pode ser precedida por
nenhuma outra ele a executa. Mais detalhadamente, temos o seguinte
pseudo-código:

\begin{lstlisting}[caption={Algoritmo de Herman e Verjus para manter a
 consistência de cópias de uma base de dados em um sistema distribuído.}]
var pid, queues, db, clock;

function estimate(i)
  return db[i];

function write(i, v)
  msg := (pid, clock, ("write", i, v));
  clock++;
  enqueue(msg, queues[pid]);
  for each p != pid
    send(msg, p);

function read(i)
  msg := (pid, clock, ("read", i));
  clock++;
  enqueue(msg, queues[msg]);
  while (!newest(msg))
    wait;
  return db[i];

function update(l)
  msg := (pid, clock, "begin");
  enqueue(msg, queues[pid]);
  for each p != pid
    send(msg, p);
  for each op in l
    execute op keeping clock value;
  msg := (pid, clock, "end");
  enqueue(msg, queues[pid]);
  for each p != pid
    send(msg, p);
  clock++;

function receive()
// ativado pelo recebimento de mensagem msg
  clock := max(clock, timestamp(msg)) + 1;
  if (type(msg) == "answer")
    send((pid, clock, "ack"), sender(msg));
    clock++;
  enqueue(msg, queues[sender(msg)]);

function process()
// ocorre paralelamente enquanto houver requisições
  for each p != pid
    if (is_empty(queues[p]))
      send((pid, clock, "answer"), p);
      clock++;
  wait for pending acks;
  op := operation of highest priority among all queues;
  execute(op);
\end{lstlisting}

Esse código merece alguns comentários. As mensagens enviadas contêm
sempre, além de seu corpo, o identificador do processo que a
enviou e o instante lógico no qual a requisição ocorreu (variável
\texttt{clock}). Mensagens de atualização são formadas pelas mensagens
das operações individuais entre mensagens especiais marcando início e
fim da transação. A precedência temporal das operações é sempre
julgada combinando-se seu tempo lógico com o identificador
requisitante, como explicado anteriormente. Como leituras e estimações
não afetam o estado geral, elas não precisam ser informadas aos outros
processos. Finalmente, exige-se um reconhecimento de processos com
filas vazias para garantir que não há uma requisição de prioridade
maior que ainda não chegou: se existir, o algoritmo esperá-la-á;
senão, o reconhecimento chegará e então ele poderá prosseguir.
